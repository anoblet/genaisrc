<!-- Generated by SpecStory -->

# Add typescript types to all .mts files in the pack (2025-04-29 16:49:22)

_**User**_

Add typescript types to all .mts files in the packages directory

---

_**Assistant**_

Remembering...

I'll help you add TypeScript types to all .mts files in the packages directory. First, let's explore the workspace structure to understand what we're working with.Remembering...

I found 4 `.genai.mts` files in the packages directory:
1. `commit.genai.mts`
2. `comment.genai.mts`
3. `style.genai.mts`
4. `message.genai.mts`

Let's examine each file to understand its structure and then add appropriate TypeScript types. I'll start with the commit script.Remembering...

Now that I've examined the first file, let me continue by reviewing the remaining files to understand their structure before adding TypeScript types.Remembering...

I've reviewed one of the four .genai.mts files. Let's continue examining the other files to understand their structure before adding TypeScript types.Remembering...

Let me continue by examining the last file before I begin adding TypeScript types to all the files.Remembering...

I've analyzed all four .genai.mts files from the packages directory and am now ready to add TypeScript types to each of them. Let me go through them one by one to add proper type definitions based on their structure and functionality.

Let's start by adding TypeScript types to the files in a systematic way:

## 1. First, let's modify the `commit.genai.mts` file:
````
// filepath: /home/andrew/Software/genaisrc/packages/commit/commit.genai.mts
import { comment } from "../comment/src/comment.genai.mts";
import { message } from "../message/src/message.genai.mts";
import { style } from "../style/src/style.genai.mts";

// Register script metadata for integration with the automation framework
script({
  model: "github_copilot_chat:gpt-4.1",
  title: "Commit",
  description: "Commit",
});

/**
 * Orchestrates the commit workflow:
 * 1. Learns code style to ensure consistency.
 * 2. Generates descriptive code comments.
 * 3. Produces a commit message and performs the commit.
 * 
 * This function abstracts the multi-step commit process to enforce best practices and maintain code quality.
 * @returns {Promise<void>} A promise that resolves when the commit workflow is complete
 */
export const commit = async (): Promise<void> => {
  await style(); // Learn code style (ensures future steps follow project conventions)
  await comment(); // Generate comments (documents code for maintainability)
  await message(); // Generate commit message and commit (finalizes the workflow)
};

export default commit;
````
Remembering...

Now I'll continue adding TypeScript types to the remaining three files, starting with the `comment.genai.mts` file:
````
// filepath: /home/andrew/Software/genaisrc/packages/comment/src/comment.genai.mts
import { fileURLToPath } from "url";
import { envArray, getFiles, stageFiles } from "../../utility/src/utility.ts";

// Script metadata for the code comment generator tool
script({
  title: "Comment",
  description: "Add AI-generated comments to your code files",
});

const promptPath = fileURLToPath(
  new URL("./comment.genai.md", import.meta.url),
);
const prompt = (await workspace.readText(promptPath)).content;

/**
 * Main entry point for the comment generator.
 * Finds relevant files, processes them to add comments, and stages the changes.
 * @returns {Promise<void>} A promise that resolves when all files have been processed
 */
export const comment = async (): Promise<void> => {
  try {
    // Retrieve files matching the configured extensions for commenting
    const files = await getFiles({
      include: envArray(process.env.GENAISCRIPT_COMMENT_EXTENSIONS),
    });

    if (files.length === 0) {
      console.log("No files found to comment.");
      return;
    }

    // Iterate through each file and attempt to process it for comment generation
    for (const file of files) {
      try {
        // Attempt to process each file individually, allowing the script to continue on error
        await processFile(file);
      } catch (error) {
        // Log errors for individual files but continue processing others
        console.log(
          `Error processing file ${typeof file === "string" ? file : file.filename}:`,
          error,
        );
      }
    }

    // Stage all processed files for commit
    await stageFiles({ files });
  } catch (error) {
    // Handle any errors that occur during the overall process
    console.error("An error occurred while generating comments:", error);
  }
};

/**
 * File interface defining the structure of file objects used in the script
 */
interface File {
  filename: string;
  content: string;
  type: string;
}

/**
 * Error response interface for comment generation failures
 */
interface ErrorResponse {
  error: {
    message: string;
    details: string;
  };
  file: string;
}

/**
 * Processes a single file by generating comments using an AI prompt and writing the result.
 * @param {File} file The file object containing filename, content, and type
 * @returns {Promise<ErrorResponse|undefined>} An object with error information if comment generation fails
 */
async function processFile(file: File): Promise<ErrorResponse | undefined> {
  try {
    // Run the AI prompt to generate comments for the file content
    const result = await runPrompt(
      (_) => {
        // Define the file content and language for the AI prompt
        _.def("FILE_CONTENT", file.content, {
          maxTokens: 10000,
          language: file.type,
        });

        // Insert the prompt template for comment generation
        _.$`${prompt}`;
      },
      {
        model: "github_copilot_chat:gpt-4.1",
        label: "Comment Code",
        system: ["system.assistant"],
        systemSafety: true,
        responseType: "text",
      },
    );

    // Overwrite the file with the commented version
    await workspace.writeText(file.filename, result.text);
  } catch (error: any) {
    console.error(`Error generating comment for file ${file.filename}:`, error);

    // Return an object with error information if comment generation fails
    return {
      error: {
        message: `Failed to generate comment for ${file.filename}`,
        details: error.message,
      },
      file: file.filename,
    };
  }
}

export default comment;
````
Remembering...

Let me continue adding TypeScript types to the remaining files. Next, I'll address the `style.genai.mts` file:
````
// filepath: /home/andrew/Software/genaisrc/packages/style/src/style.genai.mts
import { getFiles } from "../../utility/src/utility.ts";
import { fileURLToPath } from "url";

// Determine the maximum number of tokens to use for style prompts, allowing override via environment variable
const maxTokens = process.env.GENAISCRIPT_STYLE_TOKENS
  ? parseInt(process.env.GENAISCRIPT_STYLE_TOKENS, 10)
  : 10000;

// Resolve the path to the style prompt template relative to this module
const promptPath = fileURLToPath(new URL("style.prompt.md", import.meta.url));
// Load the style prompt template content from disk
const prompt = (await workspace.readText(promptPath)).content;

// Register this script with a title for discoverability in the script system
script({
  title: "Style",
});

/**
 * Interface for file objects to be processed by the style script
 */
interface StyleFile {
  filename: string;
  content: string;
  type?: string;
}

/**
 * Processes a single file by applying the code style prompt and writing the result.
 * @param {StyleFile} file The file object to process, expected to have a .content property
 * @returns {Promise<void>} A promise that resolves when the file has been processed
 */
const processFile = async (file: StyleFile): Promise<void> => {
  // Allow override of the style prompt path via environment variable for flexibility in CI or local runs
  const stylePath = process.env.GENAISCRIPT_STYLE_PROMPT_PATH || "../../../.github/prompts/style.prompt.md";

  // Load the code style definition from the specified path
  const codeStyle = await workspace.readText(stylePath);
  
  // Run the style prompt using the loaded code style and file content as context
  const result = await runPrompt(
    (_) => {
      // Define context variables for the prompt engine
      _.def("CODE_STYLE", codeStyle, {
        maxTokens,
      });
      _.def("FILE_CONTENT", file.content, {
        maxTokens,
      });
      _.def("MAX_TOKENS", String(maxTokens), {
        maxTokens,
      });
      // Inject the prompt template for execution
      _.$`${prompt}`;
    },
    {
      model: "github_copilot_chat:gpt-4.1", // Specify the LLM model to use for style suggestions
      label: "Style Code",
      system: ["system.assistant"], // Use system prompt for assistant role
      systemSafety: true, // Enable safety checks for model output
      responseType: "text",
    },
  );

  // Overwrite the style prompt file with the result, which may be an error (potentially unintended)
  await workspace.writeText(stylePath, result.text);
};

/**
 * Main entry point for the style script.
 * Finds all files to style and processes each one sequentially.
 * @returns {Promise<void>} A promise that resolves when all files have been processed
 */
export const style = async (): Promise<void> => {
  const files = await getFiles({});

  if (files.length === 0) {
    console.log("No files found to style.");
    return;
  }

  // Sequentially process each file to ensure deterministic output and avoid race conditions
  for (const file of files) {
    await processFile(file);
  }
};

export default style;
````
Remembering...

Let me finish by adding TypeScript types to the `message.genai.mts` file, which is the last file remaining:
````
// filepath: /home/andrew/Software/genaisrc/packages/message/src/message.genai.mts
/**
 * Script to generate git commit messages in the conventional commit format.
 * It automatically checks for staged changes (or stages all files if none are staged),
 * generates a commit message, and commits the changes.
 */

/**
 * Main function that handles the generation of commit messages and the commit process.
 * @returns {Promise<void>} A promise that resolves when the commit process completes
 */
export const message = async (): Promise<void> => {
  script({
    model: "github_copilot_chat:gpt-4.1",
    title: "Message",
    description: "Generate a conventional commit message for staged changes",
  });

  try {
    // Get the diff of staged changes
    const diff = await git.diff({
      excludedPaths: ["package-lock.json"],
      staged: true,
      askStageOnEmpty: false, // Don't ask since we've already handled staging
    });

    // If no staged changes are found after our attempts, exit gracefully
    if (!diff) {
      console.log("No changes to commit. Exiting.");
      return;
    }

    // Constants for chunking
    const chunkSize = 10000;
    const maxChunks = 4; // Safeguard against huge commits

    // Chunk the diff if it's large
    const chunks = await tokenizers.chunk(diff, { chunkSize });
    if (chunks.length > 1) {
      console.log(
        `Staged changes chunked into ${chunks.length} parts due to size`
      );
    }

    // Generate a commit message for each chunk, then combine them
    let message = "";
    for (const chunk of chunks) {
      const result = await runPrompt(
        (ctx) => {
          ctx.def("GIT_DIFF", chunk, {
            maxTokens: chunkSize,
            language: "diff",
            detectPromptInjection: "available",
          });

          ctx.$`Generate a git conventional commit message that summarizes the changes in GIT_DIFF.
          
          Follow the Conventional Commits specification (https://www.conventionalcommits.org/):
          <type>[optional scope]: <description>
          
          [optional body]
          
          [optional footer(s)]
          
          - <type> must be one of: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
          - <description> must be imperative, present tense, lowercase, no period at end
          - The first line (header) should be 50 chars or less
          - The body should provide context and explain what and why (not how)
          - The full message should be clear and concise
          - Do NOT use markdown syntax, quotes, or code blocks
          - Do NOT confuse removed lines starting with '-' and added lines starting with '+'`;
        },
        {
          model: "large",
          label: "generate commit message",
          system: ["system.assistant"],
          systemSafety: true,
          responseType: "text",
        }
      );

      if (result.error) {
        console.error(
          "Error generating commit message for chunk:",
          result.error
        );
        continue;
      }

      message += (result.fences?.[0]?.content || result.text).trim() + "\n";
    }

    // If we chunked the diff, generate a summary commit message from all chunks
    let commitMessage = message.trim();
    if (chunks.length > 1) {
      console.log("Generating summary commit message from all chunks...");
      const summaryResult = await runPrompt(
        (ctx) => {
          ctx.$`Generate a git conventional commit message that summarizes the following individual commit messages.`;
          ctx.def("COMMIT_MESSAGES", message, {
            maxTokens: chunkSize,
            detectPromptInjection: "available",
          });
          ctx.$`
          Follow the Conventional Commits specification (https://www.conventionalcommits.org/):
          <type>[optional scope]: <description>
          
          [optional body]
          
          [optional footer(s)]
          
          - <type> must be one of: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
          - <description> must be imperative, present tense, lowercase, no period at end
          - The first line (header) should be 50 chars or less
          - The body should provide context and explain what and why (not how)
          - The full message should be clear and concise
          - Do NOT use markdown syntax, quotes, or code blocks`;
        },
        {
          model: "large",
          label: "summarize chunk commit messages",
          system: ["system.assistant"],
          systemSafety: true,
          responseType: "text",
        }
      );

      if (!summaryResult.error) {
        commitMessage = (
          summaryResult.fences?.[0]?.content || summaryResult.text
        ).trim();
      }
    }

    if (!commitMessage) {
      console.log(
        "No commit message could be generated. Check your LLM configuration."
      );
      return;
    }

    // Commit the changes with the generated message
    console.log("Committing with message:");
    console.log(commitMessage);
    const commitResult = await git.exec(["commit", "-m", commitMessage]);
    console.log(commitResult);
  } catch (error) {
    console.error("Error occurred:", error);
  }
};

export default message;
````
I've added TypeScript type definitions to all four `.genai.mts` files in the packages directory. Here's a summary of the changes made:

1. **commit.genai.mts**:
   - Added return type annotation `Promise<void>` to the `commit` function
   - Enhanced JSDoc comments with proper return type documentation

2. **comment.genai.mts**:
   - Added return type annotation `Promise<void>` to the `comment` function
   - Created two interfaces:
     - `File` interface for file objects with filename, content, and type properties
     - `ErrorResponse` interface for error handling return values
   - Added return type annotation `Promise<ErrorResponse | undefined>` to the `processFile` function
   - Added type annotation `: any` to the error catch parameter

3. **style.genai.mts**:
   - Created `StyleFile` interface for file objects with proper type definitions
   - Added return type annotation `Promise<void>` to both the `processFile` and `style` functions
   - Added parameter type annotation to the `processFile` function

4. **message.genai.mts**:
   - Added return type annotation `Promise<void>` to the `message` function
   - Enhanced JSDoc comments with proper return type documentation

These changes follow the TypeScript best practices and adhere to the coding style preferences specified in the prompts. The type annotations make the code more maintainable, provide better documentation, and enable better IDE assistance and type checking for developers working with these scripts.

---

